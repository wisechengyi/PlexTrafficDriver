import copy
import os
import yaml
import subprocess
import logging
import git
from travispy import TravisPy

from travis_hack.credential import CREDS

logger = logging.getLogger('__EXP__')
logging.basicConfig()
logger.setLevel(logging.DEBUG)

logger.debug(CREDS)


CURRENT_REPO = git.Repo(".")


def main():

  def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in range(0, len(l), n):
      yield l[i:i + n]

  travis_yml = None
  with open(".travis.yml", 'r') as stream:
    try:
      travis_yml = yaml.load(stream)
      logger.debug(travis_yml)
    except yaml.YAMLError as exc:
      logger.error(exc)

  if travis_yml is None:
    exit(1)

  matrix = travis_yml['env']['matrix']

  chunks = list(chunks(matrix, 5))

  new_configs = []

  for chunk in chunks:
    new_config = copy.deepcopy(travis_yml)
    new_config['env']['matrix'] = chunk
    new_configs.append(new_config)

  # assert len(CREDS) >= len(new_configs)

  starting_branch = CURRENT_REPO.active_branch.name
  logger.info('Current branch: {}'.format(starting_branch))

  try:
    # current_branch = os.system('git branch | grep -e "^*" | cut -d' ' -f 2')
    for idx, config in enumerate(new_configs):
      if CURRENT_REPO.is_dirty():
        logger.error("Repo is dirty. Please commit/stash the changes first.")
        exit(1)

      # Check out a different branch
      tmp_branch = '{}_{}'.format(CURRENT_REPO.active_branch.commit.hexsha, idx)
      # CURRENT_REPO.branches
      checkout_new_branch(tmp_branch)

      username, github_token, repo_name = CREDS[idx]

      # Overwrite existing .travis.yml
      output_filename = '.travis.yml'
      with open(output_filename, 'w') as outfile:
        outfile.write(yaml.dump(config, default_flow_style=True))

      # Commit change
      subprocess.check_output('git commit -am travis_exploit'.split(' '))

      # # Push
      subprocess.check_output(
        'git push https://{username}:{token}@github.com/{username}/{repo}.git head:{branch} -f'.format(
          username=username,
          token=github_token,
          repo=repo_name,
          branch=tmp_branch
        ).split(' ')
      )

      travis = TravisPy.github_auth(github_token)
      repos = travis.repos(member=travis.user().login, slug=repo_name)
      # assert len(repos) == 1
      repo = repos[0]
      last_build = travis.build(repo.last_build_id)


      exit(0)

  finally:
    reset_to(starting_branch)
    pass


  exit(0)


def checkout_new_branch(tmp_branch):
  try:
    subprocess.check_output('git checkout -b {}'.format(tmp_branch).split(' '))
  except subprocess.CalledProcessError:
    logger.info("Checkout {} failed. likely branch already exists".format(tmp_branch))
    try:
      subprocess.check_output('git branch -D {}'.format(tmp_branch).split(' '))
    except subprocess.CalledProcessError:
      logger.error("Delete branch {} failed.".format(tmp_branch))
      exit(1)
    else:
      logger.info("Delete branch {} succeeded.".format(tmp_branch))
      try:
        subprocess.check_output('git checkout -b {}'.format(tmp_branch).split(' '))
      except subprocess.CalledProcessError:
        logger.error("Retry creating {} failed".format(tmp_branch))
        exit(1)
      else:
        logger.info('Checkout {} succeeded'.format(tmp_branch))


def get_current_branch():
  return subprocess.check_output('git rev-parse --abbrev-ref HEAD'.split(' ')).strip()


def reset_to(branch):
  if CURRENT_REPO.active_branch.name == branch:
    return
  # subprocess.check_output('git reset --hard'.split(' '))
  # subprocess.check_output('git checkout {}'.format(branch).split(' '))


if __name__ == '__main__':
  main()
