import copy
import argparse
import os
import yaml
import subprocess
import logging
import git
import random
import string
import time
from travispy import TravisPy
import json

from travispy.errors import TravisError

from credential import CREDS

logger = logging.getLogger('__EXP__')
logging.basicConfig()
logger.setLevel(logging.DEBUG)

logger.debug(CREDS)


CURRENT_REPO = git.Repo(".")
TRAVIS_YML = '.travis.yml'
CHUNK_SIZE = 5
ACCESS_TOKEN_FILE = '.token.json'

TOKEN_INSTRUCTION = """\
curl -i -H 'Content-Type: application/json' -d '{"github_token":"{}"}' -H 'User-Agent: Travis/1.0' https://api.travis-ci.org/auth/github\
"""

def main(args):

  def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in range(0, len(l), n):
      yield l[i:i + n]

  travis_yml = None
  with open(".travis.yml", 'r') as stream:
    try:
      travis_yml = yaml.load(stream)
      logger.debug(travis_yml)
    except yaml.YAMLError as exc:
      logger.error(exc)

  if travis_yml is None:
    exit(1)

  matrix = travis_yml['env']['matrix']

  chunks = list(chunks(matrix, CHUNK_SIZE))

  new_configs = []

  for chunk in chunks:
    new_config = copy.deepcopy(travis_yml)
    new_config['env']['matrix'] = chunk
    new_configs.append(new_config)

  # assert len(CREDS) >= len(new_configs)

  starting_branch = CURRENT_REPO.active_branch.name
  logger.info('Current branch: {}'.format(starting_branch))

  if CURRENT_REPO.is_dirty():
    logger.error("Repo is dirty. Please commit/stash the changes first.")
    exit(1)


  try:
    builds_info = []
    for idx, config in enumerate(new_configs):
      username, github_token, repo_name = CREDS[idx]

      if not args.skip_push:
        # Check out a different branch
        tmp_branch = get_new_branch(idx)
        checkout_new_branch(tmp_branch)

        # Overwrite existing .travis.yml
        with open(TRAVIS_YML, 'w') as outfile:
          outfile.write(yaml.dump(config, default_flow_style=True))

        # Commit change
        subprocess.check_output('git commit -am travis_exploit'.split(' '))
        tmp_branch_sha = CURRENT_REPO.active_branch.commit.hexsha

        builds_info.append((username, repo_name, tmp_branch_sha, github_token))
        # # Push
        subprocess.check_output(
          'git push https://{username}:{token}@github.com/{username}/{repo}.git head:{branch} -f'.format(
            username=username,
            token=github_token,
            repo=repo_name,
            branch=tmp_branch
          ).split(' ')
        )

    for username, repo_name, tmp_branch_sha, github_token in builds_info:
      slug = '{}/{}'.format(username, repo_name)
      # use travis token first, if failed, use github auth
      travis_session = get_travis_session(username, github_token)
      while True:
        builds = filter(lambda x: x.commit.sha == tmp_branch_sha, travis_session.builds(slug=slug))
        if not builds:
          wait = 2
          logger.info("Travis build is not catching up yet. wait {} seconds".format(wait))
          time.sleep(2)
        elif len(builds) == 1:
          logger.info("Build found. Url: https://travis-ci.org/{}/{}/builds/{}".format(username, repo_name, builds[0].id))
          break

  finally:
    reset_to(starting_branch)

def get_travis_session(username, github_token):
  if not os.path.exists(ACCESS_TOKEN_FILE):
    logger.error("{} not found.".format(ACCESS_TOKEN_FILE))
    exit(1)

  known_travis_access_tokens = json.loads(open(ACCESS_TOKEN_FILE, 'rb').read())
  if username not in known_travis_access_tokens:
    logger.error("{} not found in {}.".format(username, ACCESS_TOKEN_FILE))
    exit(1)

  token = known_travis_access_tokens[username]
  travis_session = TravisPy(token=token)
  try:
    travis_session.repo('some_repo')
  except TravisError:
    logger.error("Travis session expired for {}. Please manually generate it by doing:\n{}"
                 .format(username, TOKEN_INSTRUCTION.format(github_token)))
    exit(1)
  else:
    return travis_session
#
# def get_travis_session_via_github(username, github_token):
#   travis_session = TravisPy.github_auth(github_token)
#   travis_session._session =


def get_new_branch(idx):
  def random_word(length):
    return ''.join(random.choice(string.lowercase) for i in range(length))
  tmp_branch = None
  while True:
    tmp_branch = 'exploit_{}_{}_{}'.format(CURRENT_REPO.active_branch.commit.hexsha, idx, random_word(5))
    if tmp_branch not in CURRENT_REPO.branches:
      break
  return tmp_branch


def checkout_new_branch(tmp_branch):
  try:
    subprocess.check_output('git checkout -b {}'.format(tmp_branch).split(' '))
  except subprocess.CalledProcessError:
    logger.info("Checkout {} failed. likely branch already exists".format(tmp_branch))
    exit(1)


def get_current_branch():
  return subprocess.check_output('git rev-parse --abbrev-ref HEAD'.split(' ')).strip()


def reset_to(branch):
  if CURRENT_REPO.active_branch.name == branch:
    return
  subprocess.check_output('git reset --hard'.split(' '))
  subprocess.check_output('git checkout {}'.format(branch).split(' '))

def parse_args():
  parser = argparse.ArgumentParser()
  parser.add_argument('-d', '--skip-push', action='store_true',
                      help="Don't run any real commands")
  # parser.add_argument('-n', '--no-publish', action='store_false', dest='publish',
  #                     help='Do not publish to db')

  return parser.parse_args()

if __name__ == '__main__':
  main(parse_args())
