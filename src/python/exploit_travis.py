import argparse
import copy
import json
import logging
import random
import string
import subprocess
import time
import webbrowser

import colorlog
import git
import yaml
from travispy import TravisPy
from travispy.errors import TravisError

CURRENT_REPO = git.Repo(".")
TRAVIS_YML = '.travis.yml'
CHUNK_SIZE = 5
ACCESS_TOKEN_FILE = '.token.json'
CREDS = json.loads(open(ACCESS_TOKEN_FILE).read())

TOKEN_INSTRUCTION = """\
curl -i -H 'Content-Type: application/json' -d '{"github_token":"{}"}' -H 'User-Agent: Travis/1.0' https://api.travis-ci.org/auth/github\
"""

handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter(
  '%(log_color)s%(levelname)s:%(name)s:%(message)s'))

logger = colorlog.getLogger('[TPlumber]')
logger.setLevel(logging.INFO)
logger.addHandler(handler)


def exploit(args):
  def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in range(0, len(l), n):
      yield l[i:i + n]

  def read_travis_yml():
    with open(TRAVIS_YML, 'r') as stream:
      try:
        yml = yaml.load(stream)
        return yml
      except yaml.YAMLError as exc:
        logger.error(exc)
        exit(1)

  logger.debug(CREDS)

  travis_yml = read_travis_yml()
  matrix = travis_yml['env']['matrix']
  chunks = list(chunks(matrix, CHUNK_SIZE))
  new_configs = []
  for chunk in chunks:
    new_config = copy.deepcopy(travis_yml)
    new_config['env']['matrix'] = chunk
    new_configs.append(new_config)

  if len(CREDS) < len(new_configs):
    logger.error('Insufficient accounts. {} needed, but only {} available.'.format(len(new_configs), len(CREDS)))
    exit(1)

  starting_branch = CURRENT_REPO.active_branch.name
  logger.info('Starting branch: {}'.format(starting_branch))

  if CURRENT_REPO.is_dirty():
    logger.error("Repo is dirty. Please commit or stash first.")
    exit(1)

  try:
    builds_info = []
    for idx, config in enumerate(new_configs):
      username, repo_name, github_token, travis_ci_token = CREDS[idx]

      if not args.skip_push:
        # Check out a different branch
        tmp_branch = get_new_branch(idx)
        checkout_new_branch(tmp_branch)

        # Overwrite existing .travis.yml
        with open(TRAVIS_YML, 'w') as outfile:
          outfile.write(yaml.dump(config, default_flow_style=True))

        # Commit change

        subprocess.check_output(['git', 'commit', '-am', CURRENT_REPO.active_branch.commit.message])
        tmp_branch_sha = CURRENT_REPO.active_branch.commit.hexsha

        builds_info.append((username, repo_name, tmp_branch_sha, github_token, travis_ci_token))
        # # Push
        subprocess.check_output(
          'git push https://{username}:{token}@github.com/{username}/{repo}.git head:{branch} -f'.format(
            username=username,
            token=github_token,
            repo=repo_name,
            branch=tmp_branch
          ).split(' ')
        )
        reset_to(starting_branch)
        logger.info('Delete tmp branch: {}'.format(tmp_branch))
        CURRENT_REPO.git.branch('-D', tmp_branch)

    # Unpack as how `builds_info` is constructed.
    for username, repo_name, tmp_branch_sha, github_token, travis_ci_token in builds_info:
      slug = '{}/{}'.format(username, repo_name)
      travis_session = get_travis_session(username, travis_ci_token, github_token)
      while True:
        builds = filter(lambda x: x.commit.sha == tmp_branch_sha, travis_session.builds(slug=slug))
        if not builds:
          wait = 2
          logger.debug("Travis build is not catching up yet. wait {} seconds".format(wait))
          time.sleep(2)
        elif len(builds) == 1:
          url = calculate_build_url(username, repo_name, builds[0])
          logger.info("Build found. Url: {}".format(url))
          webbrowser.open_new_tab(url)
          break

  finally:
    reset_to(starting_branch)


def get_travis_session(username, travis_ci_token, github_token):
  travis_session = TravisPy(token=travis_ci_token)
  try:
    travis_session.repo('some_repo')
  except TravisError:
    logger.error("Travis session expired for {}. Please manually generate it by doing:\n{}"
                 .format(username, TOKEN_INSTRUCTION.format(github_token)))
    exit(1)
  else:
    return travis_session


def get_new_branch(idx):
  def random_word(length):
    return ''.join(random.choice(string.lowercase) for i in range(length))

  while True:
    tmp_branch = 'travis_tmp_br_{}_{}_{}'.format(CURRENT_REPO.active_branch.commit.hexsha, idx, random_word(5))
    if tmp_branch not in CURRENT_REPO.branches:
      return tmp_branch


def checkout_new_branch(tmp_branch):
  try:
    subprocess.check_output('git checkout -b {}'.format(tmp_branch).split(' '))
  except subprocess.CalledProcessError:
    logger.info("Checkout {} failed. likely branch already exists".format(tmp_branch))
    exit(1)


def get_current_branch():
  return subprocess.check_output('git rev-parse --abbrev-ref HEAD'.split(' ')).strip()


def reset_to(branch):
  if CURRENT_REPO.active_branch.name == branch:
    return
  subprocess.check_output('git reset --hard'.split(' '))
  subprocess.check_output('git checkout {}'.format(branch).split(' '))


def parse_args():
  parser = argparse.ArgumentParser()
  parser.add_argument('-d', '--skip-push', action='store_true',
                      help="Don't run any real commands")
  parser.add_argument("-v", "--verbose", help="increase output verbosity",
                      action="store_true")
  parser.add_argument("--stop-all", help="stop all travis builds",
                      action="store_true", default=False)
  return parser.parse_args()


def calculate_build_url(username, repo_name, build):
  return "https://travis-ci.org/{}/{}/builds/{}".format(username, repo_name, build.id)


def stop_all_builds():
  for username, repo_name, github_token, travis_ci_token in CREDS:
    travis_session = TravisPy(token=travis_ci_token)
    builds = travis_session.builds(slug="{}/{}".format(username, repo_name))
    for build in builds:
      if not build.finished:
        success = build.cancel()
        url = calculate_build_url(username, repo_name, build)
        if success:
          logger.info("Build {} aborted".format(url))
        else:
          logger.error("Build {} fails to abort".format(url))


if __name__ == '__main__':
  args = parse_args()
  if args.verbose:
    logger.setLevel(logging.DEBUG)
  logger.debug(args)
  if args.stop_all:
    stop_all_builds()
  else:
    exploit(args)
